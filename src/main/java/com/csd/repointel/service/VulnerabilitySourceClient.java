package com.csd.repointel.service;

import com.csd.repointel.model.CveVulnerabilityRecord;
import com.csd.repointel.model.VulnerabilitySeverity;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Client for fetching vulnerability data from external CVE sources.
 * Supports OSV.dev API, Mend.io, NVD, and local JSON cache fallback.
 */
@Slf4j
@Service
public class VulnerabilitySourceClient {

    private final WebClient webClient;
    private final ObjectMapper objectMapper;
    private final Map<String, List<CveVulnerabilityRecord>> cache;
    private final Map<String, CveVulnerabilityRecord> cveCache;
    private final OsvApiClient osvApiClient;

    public VulnerabilitySourceClient(OsvApiClient osvApiClient) {
        this.webClient = WebClient.builder()
                .baseUrl("https://www.mend.io")
                .build();
        this.objectMapper = new ObjectMapper();
        this.cache = new ConcurrentHashMap<>();
        this.cveCache = new ConcurrentHashMap<>();
        this.osvApiClient = osvApiClient;
        
        // Load local vulnerability database on startup
        loadLocalVulnerabilityDatabase();
    }

    /**
     * Load local vulnerability database from JSON file.
     * This serves as fallback when external sources are unavailable.
     */
    private void loadLocalVulnerabilityDatabase() {
        try {
            ClassPathResource resource = new ClassPathResource("vulnerabilities/cve-database.json");
            if (resource.exists()) {
                try (InputStream is = resource.getInputStream()) {
                    JsonNode root = objectMapper.readTree(is);
                    if (root.has("vulnerabilities") && root.get("vulnerabilities").isArray()) {
                        for (JsonNode cveNode : root.get("vulnerabilities")) {
                            CveVulnerabilityRecord record = parseCveRecord(cveNode);
                            if (record != null) {
                                String key = record.getGroupId() + ":" + record.getArtifactId();
                                cache.computeIfAbsent(key, k -> new ArrayList<>()).add(record);
                                cveCache.put(record.getCveId(), record);
                            }
                        }
                    }
                }
                log.info("Loaded {} CVE records from local database", cveCache.size());
            } else {
                log.warn("Local CVE database not found at vulnerabilities/cve-database.json");
                loadDefaultVulnerabilities();
            }
        } catch (IOException e) {
            log.error("Failed to load local CVE database: {}", e.getMessage());
            loadDefaultVulnerabilities();
        }
    }

    /**
     * Load a set of well-known vulnerabilities as fallback.
     */
    private void loadDefaultVulnerabilities() {
        log.info("Loading default vulnerability database");
        
        // Log4j vulnerabilities
        addDefaultCve("CVE-2021-44228", "org.apache.logging.log4j", "log4j-core",
                Arrays.asList(">=2.0.0,<2.17.0"), VulnerabilitySeverity.CRITICAL, 10.0,
                "Apache Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.",
                "2.17.1", "2.20.0");
        
        addDefaultCve("CVE-2021-45046", "org.apache.logging.log4j", "log4j-core",
                Arrays.asList(">=2.0.0,<2.17.0"), VulnerabilitySeverity.CRITICAL, 9.0,
                "It was found that the fix to address CVE-2021-44228 in Apache Log4j 2.15.0 was incomplete in certain non-default configurations.",
                "2.17.1", "2.20.0");
        
        addDefaultCve("CVE-2021-44832", "org.apache.logging.log4j", "log4j-core",
                Arrays.asList(">=2.0.0,<2.17.1"), VulnerabilitySeverity.MEDIUM, 6.6,
                "Apache Log4j2 vulnerable to RCE via JDBC Appender when attacker controls configuration.",
                "2.17.1", "2.20.0");
        
        // Spring Framework vulnerabilities
        addDefaultCve("CVE-2022-22965", "org.springframework", "spring-beans",
                Arrays.asList(">=5.3.0,<5.3.18", ">=5.2.0,<5.2.20"), VulnerabilitySeverity.CRITICAL, 9.8,
                "A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE) via data binding.",
                "5.3.18", "6.0.0");
        
        addDefaultCve("CVE-2022-22965", "org.springframework", "spring-webmvc",
                Arrays.asList(">=5.3.0,<5.3.18", ">=5.2.0,<5.2.20"), VulnerabilitySeverity.CRITICAL, 9.8,
                "Spring4Shell - Remote Code Execution via data binding on JDK 9+.",
                "5.3.18", "6.0.0");
        
        addDefaultCve("CVE-2022-22950", "org.springframework", "spring-expression",
                Arrays.asList(">=5.3.0,<5.3.18", ">=5.2.0,<5.2.20"), VulnerabilitySeverity.MEDIUM, 6.5,
                "Denial of Service via specifically crafted SpEL expression.",
                "5.3.18", "6.0.0");
        
        // Spring Boot vulnerabilities
        addDefaultCve("CVE-2022-22978", "org.springframework.boot", "spring-boot",
                Arrays.asList(">=2.6.0,<2.6.8", ">=2.5.0,<2.5.14"), VulnerabilitySeverity.MEDIUM, 5.4,
                "Authorization rules can be bypassed via forward or include dispatcher types in Spring Security.",
                "2.7.0", "3.2.0");
        
        addDefaultCve("CVE-2023-20873", "org.springframework.boot", "spring-boot-autoconfigure",
                Arrays.asList(">=3.0.0,<3.0.6", ">=2.7.0,<2.7.11"), VulnerabilitySeverity.MEDIUM, 7.5,
                "Spring Boot Welcome Page DoS Vulnerability.",
                "3.0.6", "3.2.0");
        
        // Jackson Databind vulnerabilities
        addDefaultCve("CVE-2020-36518", "com.fasterxml.jackson.core", "jackson-databind",
                Arrays.asList(">=2.0.0,<2.12.6.1"), VulnerabilitySeverity.HIGH, 7.5,
                "Java StackOverflow exception and denial of service via a large depth of nested objects.",
                "2.12.6.1", "2.15.0");
        
        addDefaultCve("CVE-2022-42003", "com.fasterxml.jackson.core", "jackson-databind",
                Arrays.asList(">=2.0.0,<2.13.4.2"), VulnerabilitySeverity.HIGH, 7.5,
                "Deserialization of Untrusted Data vulnerability in deep wrapper array nesting.",
                "2.13.4.2", "2.15.0");
        
        // Tomcat vulnerabilities
        addDefaultCve("CVE-2023-28708", "org.apache.tomcat", "tomcat-catalina",
                Arrays.asList(">=11.0.0-M1,<11.0.0-M5", ">=10.1.0,<10.1.8", ">=9.0.0,<9.0.74"), VulnerabilitySeverity.HIGH, 7.5,
                "Apache Tomcat information disclosure vulnerability.",
                "10.1.8", "10.1.20");
        
        addDefaultCve("CVE-2023-28709", "org.apache.tomcat.embed", "tomcat-embed-core",
                Arrays.asList(">=11.0.0-M1,<11.0.0-M5", ">=10.1.0,<10.1.8", ">=9.0.0,<9.0.74"), VulnerabilitySeverity.HIGH, 7.5,
                "Apache Tomcat RemoteIpFilter can allow a crafted request to produce incorrect results.",
                "10.1.8", "10.1.20");
        
        // JUnit vulnerabilities
        addDefaultCve("CVE-2020-15250", "junit", "junit",
                Arrays.asList(">=4.0,<4.13.1"), VulnerabilitySeverity.MEDIUM, 5.5,
                "JUnit4 uses Java's reflection and classloader systems to load potentially untrusted data.",
                "4.13.1", "4.13.2");
        
        // Commons IO vulnerabilities
        addDefaultCve("CVE-2021-29425", "commons-io", "commons-io",
                Arrays.asList(">=1.0,<2.7"), VulnerabilitySeverity.MEDIUM, 4.8,
                "In Apache Commons IO, the FileNameUtils.normalize method can produce incorrect results on Windows.",
                "2.7", "2.11.0");
        
        // Logback vulnerabilities
        addDefaultCve("CVE-2021-42550", "ch.qos.logback", "logback-core",
                Arrays.asList(">=0.9.0,<1.2.9"), VulnerabilitySeverity.HIGH, 7.5,
                "Logback allows attackers to trigger a denial of service (DoS) via a malicious crafted serialized object.",
                "1.2.9", "1.4.0");
        
        addDefaultCve("CVE-2021-42550", "ch.qos.logback", "logback-classic",
                Arrays.asList(">=0.9.0,<1.2.9"), VulnerabilitySeverity.HIGH, 7.5,
                "Logback allows attackers to trigger a denial of service (DoS) via a malicious crafted serialized object.",
                "1.2.9", "1.4.0");
        
        // Hibernate vulnerabilities
        addDefaultCve("CVE-2020-25638", "org.hibernate", "hibernate-core",
                Arrays.asList(">=5.0.0,<5.4.24"), VulnerabilitySeverity.HIGH, 7.4,
                "A flaw was found in Hibernate ORM where SQL injection is possible via unsafe handling of criteria query.",
                "5.4.24", "6.2.0");
        
        // MySQL Connector vulnerabilities
        addDefaultCve("CVE-2021-22573", "mysql", "mysql-connector-java",
                Arrays.asList(">=8.0.0,<8.0.28"), VulnerabilitySeverity.HIGH, 8.3,
                "Difficult to exploit vulnerability allows unauthenticated attacker with network access via multiple protocols to compromise MySQL Connectors.",
                "8.0.28", "8.3.0");
        
        // PostgreSQL Driver vulnerabilities
        addDefaultCve("CVE-2022-31197", "org.postgresql", "postgresql",
                Arrays.asList(">=42.0.0,<42.2.26", ">=42.3.0,<42.3.7", ">=42.4.0,<42.4.1"), VulnerabilitySeverity.HIGH, 8.0,
                "SQL Injection in ResultSet.refreshRow() with malicious column names.",
                "42.4.1", "42.6.0");
        
        // Netty vulnerabilities
        addDefaultCve("CVE-2023-34462", "io.netty", "netty-handler",
                Arrays.asList(">=4.1.0,<4.1.94"), VulnerabilitySeverity.MEDIUM, 6.5,
                "SniHandler hostname can cause OutOfMemoryError, remote DOS.",
                "4.1.94", "4.1.100");
        
        // Guava vulnerabilities
        addDefaultCve("CVE-2020-8908", "com.google.guava", "guava",
                Arrays.asList(">=10.0,<30.0"), VulnerabilitySeverity.LOW, 3.3,
                "Local information disclosure vulnerability due to temporary directory creation.",
                "30.0", "32.1.3");
        
        // Snakeyaml vulnerabilities
        addDefaultCve("CVE-2022-1471", "org.yaml", "snakeyaml",
                Arrays.asList(">=1.0,<2.0"), VulnerabilitySeverity.CRITICAL, 9.8,
                "SnakeYaml's Constructor() class does not restrict types which can be instantiated during deserialization.",
                "2.0", "2.2");
        
        // Commons Codec
        addDefaultCve("CVE-2012-5783", "commons-codec", "commons-codec",
                Arrays.asList(">=1.0,<1.7"), VulnerabilitySeverity.MEDIUM, 5.9,
                "Apache Commons Codec does not properly restrict the length of nonce values.",
                "1.7", "1.16.0");
        
        log.info("Loaded {} default CVE records", cveCache.size());
    }

    private void addDefaultCve(String cveId, String groupId, String artifactId, List<String> affectedVersions,
                                VulnerabilitySeverity severity, double cvssScore, String description,
                                String recommendedVersion, String latestVersion) {
        CveVulnerabilityRecord record = CveVulnerabilityRecord.builder()
                .cveId(cveId)
                .groupId(groupId)
                .artifactId(artifactId)
                .packageName(artifactId)
                .affectedVersions(affectedVersions)
                .severity(severity)
                .cvssScore(cvssScore)
                .description(description)
                .solution("Upgrade to version " + recommendedVersion + " or later")
                .recommendedVersion(recommendedVersion)
                .latestVersion(latestVersion)
                .publishedDate(LocalDateTime.now().minusMonths(6))
                .source("default-database")
                .references(Arrays.asList(
                        "https://nvd.nist.gov/vuln/detail/" + cveId,
                        "https://www.cve.org/CVERecord?id=" + cveId
                ))
                .build();
        
        String key = groupId + ":" + artifactId;
        cache.computeIfAbsent(key, k -> new ArrayList<>()).add(record);
        cveCache.put(cveId, record);
    }

    /**
     * Get vulnerabilities for a specific package from cache.
     */
    public List<CveVulnerabilityRecord> getVulnerabilitiesForPackage(String groupId, String artifactId) {
        String key = groupId + ":" + artifactId;
        return cache.getOrDefault(key, Collections.emptyList());
    }

    /**
     * Get vulnerabilities for a specific package version from OSV.dev API AND cache.
     * This method combines real-time OSV.dev data with local cache for comprehensive coverage.
     */
    public List<CveVulnerabilityRecord> getVulnerabilitiesForPackageVersion(String groupId, String artifactId, String version) {
        // Query OSV.dev for real-time vulnerabilities
        List<CveVulnerabilityRecord> osvVulnerabilities = osvApiClient.queryVulnerabilities(groupId, artifactId, version);
        
        // Also check local cache
        List<CveVulnerabilityRecord> cachedVulnerabilities = getVulnerabilitiesForPackage(groupId, artifactId);
        
        // Merge results, avoiding duplicates by CVE ID
        Set<String> seenCveIds = new HashSet<>();
        List<CveVulnerabilityRecord> allVulnerabilities = new ArrayList<>();
        
        // Add OSV vulnerabilities first (real-time data is more accurate)
        for (CveVulnerabilityRecord vuln : osvVulnerabilities) {
            if (seenCveIds.add(vuln.getCveId())) {
                allVulnerabilities.add(vuln);
            }
        }
        
        // Add cached vulnerabilities that weren't already found
        for (CveVulnerabilityRecord vuln : cachedVulnerabilities) {
            if (seenCveIds.add(vuln.getCveId())) {
                allVulnerabilities.add(vuln);
            }
        }
        
        if (!allVulnerabilities.isEmpty()) {
            log.info("Found {} total vulnerabilities for {}:{}:{} ({} from OSV.dev, {} from cache)", 
                    allVulnerabilities.size(), groupId, artifactId, version, 
                    osvVulnerabilities.size(), cachedVulnerabilities.size());
        }
        
        return allVulnerabilities;
    }

    /**
     * Get vulnerability by CVE ID.
     */
    public Optional<CveVulnerabilityRecord> getVulnerabilityByCveId(String cveId) {
        return Optional.ofNullable(cveCache.get(cveId));
    }

    /**
     * Fetch vulnerability data from Mend.io (asynchronous, with timeout).
     */
    public Mono<CveVulnerabilityRecord> fetchFromMendIo(String cveId) {
        return webClient.get()
                .uri("/vulnerability-database/" + cveId)
                .retrieve()
                .bodyToMono(JsonNode.class)
                .timeout(Duration.ofSeconds(5))
                .map(this::parseCveRecord)
                .doOnError(e -> log.warn("Failed to fetch CVE {} from Mend.io: {}", cveId, e.getMessage()))
                .onErrorReturn(null);
    }

    /**
     * Parse CVE record from JSON node.
     */
    private CveVulnerabilityRecord parseCveRecord(JsonNode node) {
        try {
            String cveId = node.has("cve") ? node.get("cve").asText() : node.get("id").asText();
            String packageName = node.has("package") ? node.get("package").asText() : "";
            String groupId = node.has("groupId") ? node.get("groupId").asText() : "";
            String artifactId = node.has("artifactId") ? node.get("artifactId").asText() : packageName;
            
            List<String> affectedVersions = new ArrayList<>();
            if (node.has("affectedVersions")) {
                if (node.get("affectedVersions").isArray()) {
                    node.get("affectedVersions").forEach(v -> affectedVersions.add(v.asText()));
                } else {
                    affectedVersions.add(node.get("affectedVersions").asText());
                }
            }
            
            String severityStr = node.has("severity") ? node.get("severity").asText() : "UNKNOWN";
            VulnerabilitySeverity severity = VulnerabilitySeverity.fromString(severityStr);
            
            double cvssScore = node.has("cvssScore") ? node.get("cvssScore").asDouble() : 0.0;
            
            return CveVulnerabilityRecord.builder()
                    .cveId(cveId)
                    .groupId(groupId)
                    .artifactId(artifactId)
                    .packageName(packageName)
                    .affectedVersions(affectedVersions)
                    .severity(severity)
                    .cvssScore(cvssScore)
                    .description(node.has("description") ? node.get("description").asText() : "")
                    .solution(node.has("solution") ? node.get("solution").asText() : "")
                    .recommendedVersion(node.has("recommendedVersion") ? node.get("recommendedVersion").asText() : null)
                    .latestVersion(node.has("latestVersion") ? node.get("latestVersion").asText() : null)
                    .source(node.has("source") ? node.get("source").asText() : "external")
                    .build();
        } catch (Exception e) {
            log.error("Failed to parse CVE record: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Get all cached vulnerabilities.
     */
    public Map<String, List<CveVulnerabilityRecord>> getAllVulnerabilities() {
        return new HashMap<>(cache);
    }

    /**
     * Get total CVE count.
     */
    public int getTotalCveCount() {
        return cveCache.size();
    }

    /**
     * Clear cache (for testing or manual refresh).
     */
    public void clearCache() {
        cache.clear();
        cveCache.clear();
    }
}
