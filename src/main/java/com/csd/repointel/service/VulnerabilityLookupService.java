package com.csd.repointel.service;

import com.csd.repointel.model.CveVulnerabilityRecord;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Service for looking up vulnerability information from multiple sources.
 * Orchestrates VulnerabilitySourceClient and provides caching and version matching.
 */
@Service
@Slf4j
public class VulnerabilityLookupService {

    private final VulnerabilitySourceClient sourceClient;

    public VulnerabilityLookupService(VulnerabilitySourceClient sourceClient) {
        this.sourceClient = sourceClient;
    }

    /**
     * Get all vulnerabilities for a specific package (groupId:artifactId)
     */
    public List<CveVulnerabilityRecord> getVulnerabilitiesForPackage(String groupId, String artifactId) {
        log.debug("Looking up vulnerabilities for {}:{}", groupId, artifactId);
        return sourceClient.getVulnerabilitiesForPackage(groupId, artifactId);
    }

    /**
     * Get vulnerabilities that affect a specific version.
     * Uses OSV.dev API for real-time lookups combined with local cache.
     */
    public List<CveVulnerabilityRecord> getVulnerabilitiesForVersion(String groupId, String artifactId, String version) {
        log.info("Looking up vulnerabilities for {}:{}:{}", groupId, artifactId, version);
        
        // Normalize npm semver prefixes (e.g., ^1.2.3 or ~1.2.3)
        String normalizedVersion = version;
        if (normalizedVersion != null) {
            normalizedVersion = normalizedVersion.trim();
            if (normalizedVersion.startsWith("^") || normalizedVersion.startsWith("~")) {
                normalizedVersion = normalizedVersion.substring(1);
            }
        }

        // Use new method that queries OSV.dev API + local cache
        List<CveVulnerabilityRecord> allVulnerabilities = sourceClient.getVulnerabilitiesForPackageVersion(groupId, artifactId, normalizedVersion);
        log.info("Found {} total CVEs for {}:{}:{} (including OSV.dev results)", allVulnerabilities.size(), groupId, artifactId, normalizedVersion);
        
        List<CveVulnerabilityRecord> affectingVersion = new ArrayList<>();

        for (CveVulnerabilityRecord cve : allVulnerabilities) {
            if (isVersionAffected(version, cve.getAffectedVersions())) {
                log.info("Version {} IS AFFECTED by {} ({})", version, cve.getCveId(), cve.getAffectedVersions());
                affectingVersion.add(cve);
            } else {
                log.debug("Version {} NOT affected by {} ({})", version, cve.getCveId(), cve.getAffectedVersions());
            }
        }

        log.info("Found {} vulnerabilities affecting {}:{}:{}", affectingVersion.size(), groupId, artifactId, version);
        return affectingVersion;
    }

    /**
     * Get specific CVE by ID
     */
    public Optional<CveVulnerabilityRecord> getVulnerabilityByCveId(String cveId) {
        return sourceClient.getVulnerabilityByCveId(cveId);
    }

    /**
     * Check if a version is affected by given version ranges
     * Supports formats: ">=2.0.0,<2.17.0", "<=2.17.0", "2.0.0-2.16.0", etc.
     */
    public boolean isVersionAffected(String version, List<String> affectedRanges) {
        if (affectedRanges == null || affectedRanges.isEmpty()) {
            return false;
        }

        for (String range : affectedRanges) {
            if (matchesVersionRange(version, range)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if version matches a specific range pattern
     */
    private boolean matchesVersionRange(String version, String range) {
        try {
            // Handle range with comma separator: ">=2.0.0,<2.17.0"
            if (range.contains(",")) {
                String[] parts = range.split(",");
                boolean matches = true;
                for (String part : parts) {
                    matches = matches && matchesSingleCondition(version, part.trim());
                }
                return matches;
            }

            // Handle dash range: "2.0.0-2.16.0"
            if (range.contains("-") && !range.startsWith(">=") && !range.startsWith("<=")) {
                String[] parts = range.split("-");
                if (parts.length == 2) {
                    int compareStart = compareVersions(version, parts[0].trim());
                    int compareEnd = compareVersions(version, parts[1].trim());
                    return compareStart >= 0 && compareEnd <= 0;
                }
            }

            // Handle single condition: ">=2.0.0", "<=2.17.0", etc.
            return matchesSingleCondition(version, range);

        } catch (Exception e) {
            log.warn("Error parsing version range '{}' for version '{}': {}", range, version, e.getMessage());
            return false;
        }
    }

    /**
     * Check if version matches a single condition (>=, <=, <, >, =)
     */
    private boolean matchesSingleCondition(String version, String condition) {
        condition = condition.trim();

        if (condition.startsWith(">=")) {
            return compareVersions(version, condition.substring(2).trim()) >= 0;
        } else if (condition.startsWith("<=")) {
            return compareVersions(version, condition.substring(2).trim()) <= 0;
        } else if (condition.startsWith(">")) {
            return compareVersions(version, condition.substring(1).trim()) > 0;
        } else if (condition.startsWith("<")) {
            return compareVersions(version, condition.substring(1).trim()) < 0;
        } else if (condition.startsWith("=")) {
            return compareVersions(version, condition.substring(1).trim()) == 0;
        } else {
            // Exact match
            return compareVersions(version, condition) == 0;
        }
    }

    /**
     * Compare two Maven version strings
     * Returns: negative if v1 < v2, zero if v1 == v2, positive if v1 > v2
     */
    private int compareVersions(String v1, String v2) {
        if (v1.equals(v2)) {
            return 0;
        }

        String[] parts1 = v1.split("[.\\-]");
        String[] parts2 = v2.split("[.\\-]");

        int maxLength = Math.max(parts1.length, parts2.length);

        for (int i = 0; i < maxLength; i++) {
            int num1 = i < parts1.length ? parseVersionPart(parts1[i]) : 0;
            int num2 = i < parts2.length ? parseVersionPart(parts2[i]) : 0;

            if (num1 != num2) {
                return Integer.compare(num1, num2);
            }
        }

        return 0;
    }

    /**
     * Parse version part to integer, handling non-numeric suffixes
     */
    private int parseVersionPart(String part) {
        try {
            // Try to parse as integer
            return Integer.parseInt(part);
        } catch (NumberFormatException e) {
            // Handle suffixes like "RELEASE", "Final", "GA", etc.
            String numericPart = part.replaceAll("[^0-9]", "");
            if (!numericPart.isEmpty()) {
                return Integer.parseInt(numericPart);
            }
            return 0;
        }
    }

    /**
     * Get total number of CVEs in cache
     */
    public int getTotalCveCount() {
        return sourceClient.getTotalCveCount();
    }

    /**
     * Clear all cached vulnerabilities
     */
    public void clearCache() {
        sourceClient.clearCache();
        log.info("Vulnerability cache cleared");
    }
}
