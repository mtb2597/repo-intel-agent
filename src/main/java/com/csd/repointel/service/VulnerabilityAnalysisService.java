package com.csd.repointel.service;

import com.csd.repointel.model.*;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Core service for analyzing repository dependencies against CVE database.
 * Generates comprehensive vulnerability reports with risk scores and recommendations.
 */
@Service
@Slf4j
public class VulnerabilityAnalysisService {

    private final VulnerabilityLookupService lookupService;
    private final RepoScanService repoScanService;

    public VulnerabilityAnalysisService(VulnerabilityLookupService lookupService,
                                       RepoScanService repoScanService) {
        this.lookupService = lookupService;
        this.repoScanService = repoScanService;
    }

    /**
     * Analyze all scanned repositories for vulnerabilities
     */
    public List<RepoVulnerabilityReport> analyzeAllRepositories() {
        log.info("Starting vulnerability analysis for all repositories");
        List<RepoVulnerabilityReport> reports = new ArrayList<>();

        Map<String, List<DependencyInfo>> allDependencies = repoScanService.getRepoDependencies();
        for (Map.Entry<String, List<DependencyInfo>> entry : allDependencies.entrySet()) {
            String repoName = entry.getKey();
            List<DependencyInfo> dependencies = entry.getValue();

            try {
                RepoVulnerabilityReport report = analyzeRepository(repoName, dependencies);
                reports.add(report);
            } catch (Exception e) {
                log.error("Error analyzing repository {}: {}", repoName, e.getMessage(), e);
            }
        }

        log.info("Completed vulnerability analysis for {} repositories", reports.size());
        return reports;
    }

    /**
     * Analyze a specific repository by name
     */
    public RepoVulnerabilityReport analyzeRepositoryByName(String repoName) {
        log.info("Analyzing repository: {}", repoName);
        List<DependencyInfo> dependencies = repoScanService.getRepoDependencies().get(repoName);
        if (dependencies == null) {
            throw new IllegalArgumentException("Repository not found or not scanned: " + repoName);
        }
        return analyzeRepository(repoName, dependencies);
    }

    /**
     * Analyze a repository's dependencies for vulnerabilities
     */
    private RepoVulnerabilityReport analyzeRepository(String repoName, List<DependencyInfo> dependencies) {
        List<DependencyVulnerability> vulnerabilities = new ArrayList<>();

        // Analyze each dependency
        for (DependencyInfo dep : dependencies) {
            DependencyVulnerability vulnerability = analyzeDependency(dep);
            vulnerabilities.add(vulnerability);
        }

        // Calculate statistics
        VulnerabilityStatistics statistics = calculateStatistics(vulnerabilities);

        // Calculate risk and health scores
        double riskScore = calculateRiskScore(vulnerabilities);
        int healthScore = calculateHealthScore(statistics);

        // Determine risk level
        String riskLevel = determineRiskLevel(riskScore);

        // Generate recommendations
        List<String> recommendations = generateRecommendations(vulnerabilities, statistics);

        // Check if fixes are available
        boolean fixAvailable = vulnerabilities.stream().anyMatch(v -> 
            v.getStatus() == VulnerabilityStatus.VULNERABLE && v.getRecommendedVersion() != null
        );

        return RepoVulnerabilityReport.builder()
                .repoName(repoName)
                .repoUrl("workdir/" + repoName)
                .scanDate(LocalDateTime.now())
                .vulnerabilities(vulnerabilities)
                .statistics(statistics)
                .riskScore(riskScore)
                .healthScore(healthScore)
                .riskLevel(riskLevel)
                .recommendations(recommendations)
                .fixAvailable(fixAvailable)
                .build();
    }

    /**
     * Analyze a single dependency for vulnerabilities
     */
    private DependencyVulnerability analyzeDependency(DependencyInfo dep) {
        String groupId = dep.getGroupId();
        String artifactId = dep.getArtifactId();
        String version = dep.getVersion();

        // Look up vulnerabilities for this package
        List<CveVulnerabilityRecord> cves = lookupService.getVulnerabilitiesForVersion(groupId, artifactId, version);

        if (!cves.isEmpty()) {
            // Vulnerable - use the highest severity CVE
            CveVulnerabilityRecord highestSeverityCve = cves.stream()
                    .max(Comparator.comparing(CveVulnerabilityRecord::getCvssScore))
                    .orElse(cves.get(0));

            return DependencyVulnerability.builder()
                    .groupId(groupId)
                    .artifactId(artifactId)
                    .currentVersion(version)
                    .status(VulnerabilityStatus.VULNERABLE)
                    .cveId(highestSeverityCve.getCveId())
                    .affectedRange(String.join(", ", highestSeverityCve.getAffectedVersions()))
                    .severity(highestSeverityCve.getSeverity())
                    .cvssScore(highestSeverityCve.getCvssScore())
                    .description(highestSeverityCve.getDescription())
                    .recommendedVersion(highestSeverityCve.getRecommendedVersion())
                    .latestVersion(highestSeverityCve.getLatestVersion())
                    .daysOld(calculateDaysOld(version, groupId, artifactId))
                    .hasNewerVersion(highestSeverityCve.getRecommendedVersion() != null)
                    .fixAvailable(highestSeverityCve.getRecommendedVersion() != null ? "yes" : "no")
                    .build();
        } else {
            // Check if there are any CVEs for this package (to determine SAFE vs UNKNOWN)
            List<CveVulnerabilityRecord> allCves = lookupService.getVulnerabilitiesForPackage(groupId, artifactId);
            VulnerabilityStatus status = allCves.isEmpty() ? VulnerabilityStatus.UNKNOWN : VulnerabilityStatus.SAFE;

            return DependencyVulnerability.builder()
                    .groupId(groupId)
                    .artifactId(artifactId)
                    .currentVersion(version)
                    .status(status)
                    .severity(VulnerabilitySeverity.NONE)
                    .cvssScore(0.0)
                    .description(status == VulnerabilityStatus.SAFE ? 
                        "No known vulnerabilities" : "Vulnerability status unknown")
                    .daysOld(calculateDaysOld(version, groupId, artifactId))
                    .hasNewerVersion(false)
                    .fixAvailable("no")
                    .build();
        }
    }

    /**
     * Calculate statistics from vulnerability list
     */
    private VulnerabilityStatistics calculateStatistics(List<DependencyVulnerability> vulnerabilities) {
        int totalDependencies = vulnerabilities.size();
        int vulnerableCount = (int) vulnerabilities.stream()
                .filter(v -> v.getStatus() == VulnerabilityStatus.VULNERABLE)
                .count();
        int safeCount = (int) vulnerabilities.stream()
                .filter(v -> v.getStatus() == VulnerabilityStatus.SAFE)
                .count();
        int unknownCount = (int) vulnerabilities.stream()
                .filter(v -> v.getStatus() == VulnerabilityStatus.UNKNOWN)
                .count();
        int outdatedCount = (int) vulnerabilities.stream()
                .filter(DependencyVulnerability::isOutdated)
                .count();

        int criticalCount = (int) vulnerabilities.stream()
                .filter(v -> v.getSeverity() == VulnerabilitySeverity.CRITICAL)
                .count();
        int highCount = (int) vulnerabilities.stream()
                .filter(v -> v.getSeverity() == VulnerabilitySeverity.HIGH)
                .count();
        int mediumCount = (int) vulnerabilities.stream()
                .filter(v -> v.getSeverity() == VulnerabilitySeverity.MEDIUM)
                .count();
        int lowCount = (int) vulnerabilities.stream()
                .filter(v -> v.getSeverity() == VulnerabilitySeverity.LOW)
                .count();

        int totalCves = (int) vulnerabilities.stream()
                .filter(v -> v.getCveId() != null)
                .count();

        double avgDaysOld = vulnerabilities.stream()
                .mapToInt(DependencyVulnerability::getDaysOld)
                .average()
                .orElse(0.0);

        Optional<DependencyVulnerability> mostOutdated = vulnerabilities.stream()
                .max(Comparator.comparingInt(DependencyVulnerability::getDaysOld));

        double avgRiskScore = calculateRiskScore(vulnerabilities);
        int avgHealthScore = calculateHealthScore(
            VulnerabilityStatistics.builder()
                .totalDependencies(totalDependencies)
                .vulnerableDependencies(vulnerableCount)
                .build()
        );

        return VulnerabilityStatistics.builder()
                .totalDependencies(totalDependencies)
                .vulnerableDependencies(vulnerableCount)
                .safeDependencies(safeCount)
                .unknownDependencies(unknownCount)
                .outdatedDependencies(outdatedCount)
                .criticalCount(criticalCount)
                .highCount(highCount)
                .mediumCount(mediumCount)
                .lowCount(lowCount)
                .averageRiskScore(avgRiskScore)
                .averageHealthScore(avgHealthScore)
                .totalCves(totalCves)
                .averageDaysOld((int) avgDaysOld)
                .mostOutdatedDays(mostOutdated.map(DependencyVulnerability::getDaysOld).orElse(0))
                .mostOutdatedPackage(mostOutdated.map(v -> v.getGroupId() + ":" + v.getArtifactId()).orElse(null))
                .build();
    }

    /**
     * Calculate risk score (0-100) based on vulnerabilities
     * Weighted by severity: CRITICAL=10, HIGH=5, MEDIUM=2, LOW=1
     */
    private double calculateRiskScore(List<DependencyVulnerability> vulnerabilities) {
        double score = 0;
        for (DependencyVulnerability vuln : vulnerabilities) {
            switch (vuln.getSeverity()) {
                case CRITICAL -> score += 10.0;
                case HIGH -> score += 5.0;
                case MEDIUM -> score += 2.0;
                case LOW -> score += 1.0;
                default -> score += 0;
            }
        }
        return Math.min(score, 100.0);
    }

    /**
     * Calculate health score (0-100) based on statistics
     * Higher is better
     */
    private int calculateHealthScore(VulnerabilityStatistics stats) {
        if (stats.getTotalDependencies() == 0) {
            return 100;
        }

        // Start with perfect score
        int score = 100;

        // Deduct points for vulnerabilities
        score -= stats.getVulnerableDependencies() * 5;

        // Deduct points for outdated dependencies
        score -= stats.getOutdatedDependencies() * 2;

        // Extra deduction for critical vulnerabilities
        score -= stats.getCriticalCount() * 10;

        return Math.max(0, Math.min(100, score));
    }

    /**
     * Determine risk level based on risk score
     */
    private String determineRiskLevel(double riskScore) {
        if (riskScore >= 50) return "Critical";
        if (riskScore >= 20) return "High";
        if (riskScore >= 5) return "Medium";
        if (riskScore > 0) return "Low";
        return "Safe";
    }

    /**
     * Generate recommendations based on vulnerabilities
     */
    private List<String> generateRecommendations(List<DependencyVulnerability> vulnerabilities,
                                                 VulnerabilityStatistics statistics) {
        List<String> recommendations = new ArrayList<>();

        if (statistics.getCriticalCount() > 0) {
            recommendations.add(String.format("âš ï¸ URGENT: Address %d critical vulnerabilities immediately", 
                statistics.getCriticalCount()));
        }

        if (statistics.getHighCount() > 0) {
            recommendations.add(String.format("âš ï¸ Address %d high-severity vulnerabilities as soon as possible", 
                statistics.getHighCount()));
        }

        if (statistics.getVulnerableDependencies() > 0) {
            long fixableCount = vulnerabilities.stream()
                    .filter(v -> v.getStatus() == VulnerabilityStatus.VULNERABLE && v.getRecommendedVersion() != null)
                    .count();
            recommendations.add(String.format("ðŸ”§ %d vulnerabilities can be fixed by updating dependencies", 
                fixableCount));
        }

        if (statistics.getOutdatedDependencies() > 5) {
            recommendations.add(String.format("ðŸ“… Consider updating %d outdated dependencies", 
                statistics.getOutdatedDependencies()));
        }

        if (statistics.getUnknownDependencies() > 10) {
            recommendations.add("â“ Many dependencies have unknown vulnerability status - consider updating CVE database");
        }

        if (recommendations.isEmpty()) {
            recommendations.add("âœ… No immediate security concerns detected");
        }

        return recommendations;
    }

    /**
     * Calculate days since version release (placeholder - returns random value)
     * In production, this would query Maven Central or similar
     */
    private int calculateDaysOld(String version, String groupId, String artifactId) {
        // Placeholder: estimate based on version pattern
        // In production, query Maven Central or similar repository
        try {
            String[] parts = version.split("\\.");
            if (parts.length >= 2) {
                int major = Integer.parseInt(parts[0].replaceAll("[^0-9]", ""));
                int minor = parts.length > 1 ? Integer.parseInt(parts[1].replaceAll("[^0-9]", "")) : 0;
                
                // Rough estimation: older major versions are older
                return (10 - Math.min(major, 5)) * 365 + (12 - Math.min(minor, 10)) * 30;
            }
        } catch (Exception e) {
            // Ignore parsing errors
        }
        return 180; // Default: 6 months
    }

    /**
     * Get summary of all vulnerabilities across all repos
     */
    public VulnerabilityStatistics getGlobalStatistics() {
        List<RepoVulnerabilityReport> allReports = analyzeAllRepositories();
        
        if (allReports.isEmpty()) {
            return VulnerabilityStatistics.builder()
                    .totalDependencies(0)
                    .build();
        }

        // Aggregate all vulnerabilities
        List<DependencyVulnerability> allVulnerabilities = allReports.stream()
                .flatMap(report -> report.getVulnerabilities().stream())
                .collect(Collectors.toList());

        return calculateStatistics(allVulnerabilities);
    }
}
