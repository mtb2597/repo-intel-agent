package com.csd.repointel.service;

import com.csd.repointel.model.*;
import com.github.difflib.DiffUtils;
import com.github.difflib.UnifiedDiffUtils;
import com.github.difflib.patch.Patch;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Service for generating vulnerability fixes with real pom.xml patching.
 * 
 * CRITICAL RULES:
 * - ONLY generates fixes for vulnerabilities with real fixedVersion from data sources
 * - NEVER invents or assumes version numbers (no "latest", no guessing)
 * - If recommendedVersion is null, the vulnerability is NOT included in fix bundle
 * - All version changes are based on OSV.dev, Mend, or local CVE database
 * - Validates that fixed version exists before generating patch
 */
@Service
@Slf4j
public class VulnerabilityFixService {

    private final VulnerabilityAnalysisService analysisService;
    private final Path tempDir = Path.of(System.getProperty("java.io.tmpdir"), "vulnerability-fixes");

    public VulnerabilityFixService(VulnerabilityAnalysisService analysisService) {
        this.analysisService = analysisService;
        
        // Create temp directory
        try {
            Files.createDirectories(tempDir);
        } catch (IOException e) {
            log.error("Failed to create temp directory: {}", e.getMessage());
        }
    }

    /**
     * Generate fix bundle for a repository.
     * ONLY includes vulnerabilities with real, data-backed fixed versions.
     */
    public FixBundle generateFixBundle(String repoName) throws IOException {
        log.info("Generating fix bundle for repository: {}", repoName);

        // Get vulnerability report
        RepoVulnerabilityReport report = analysisService.analyzeRepositoryByName(repoName);

        // Get vulnerabilities that can be fixed (ONLY those with real fixed versions)
        List<DependencyVulnerability> fixableVulnerabilities = report.getVulnerabilities().stream()
                .filter(v -> v.getStatus() == VulnerabilityStatus.VULNERABLE && v.getRecommendedVersion() != null)
                .collect(Collectors.toList());

        if (fixableVulnerabilities.isEmpty()) {
            throw new IllegalStateException("No fixable vulnerabilities found for repository: " + repoName);
        }

        // Find pom.xml and package.json files in the repository
        Path repoPath = Path.of(report.getRepoUrl());
        List<PomFile> pomFiles = findPomFiles(repoPath);
        List<NpmFile> npmFiles = findPackageJsonFiles(repoPath);

        // Generate patches for each pom.xml and package.json
        List<PomPatch> patches = new ArrayList<>();
        for (PomFile pomFile : pomFiles) {
            PomPatch patch = generatePomPatch(pomFile, fixableVulnerabilities);
            if (patch.hasChanges()) {
                patches.add(patch);
            }
        }
        for (NpmFile npmFile : npmFiles) {
            PomPatch patch = generatePackageJsonPatch(npmFile, fixableVulnerabilities);
            if (patch.hasChanges()) {
                patches.add(patch);
            }
        }

        if (patches.isEmpty()) {
            throw new IllegalStateException("No dependency files (pom.xml or package.json) found with fixable dependencies");
        }

        // Generate commit message
        String commitMessage = generateCommitMessage(fixableVulnerabilities);

        // Generate PR description
        String prDescription = generatePRDescription(report, fixableVulnerabilities);

        // Create ZIP bundle
        Path zipPath = createZipBundle(repoName, patches, commitMessage, prDescription);

        return FixBundle.builder()
                .repoName(repoName)
                .patches(patches)
                .commitMessage(commitMessage)
                .prDescription(prDescription)
                .zipPath(zipPath.toString())
                .fixedCount(fixableVulnerabilities.size())
                .build();
    }

    /**
     * Find all pom.xml files in repository
     */
    private List<PomFile> findPomFiles(Path repoPath) throws IOException {
        List<PomFile> pomFiles = new ArrayList<>();

        try (var stream = Files.walk(repoPath)) {
            List<Path> pomPaths = stream
                    .filter(path -> path.getFileName().toString().equals("pom.xml"))
                    .collect(Collectors.toList());

            for (Path pomPath : pomPaths) {
                String content = Files.readString(pomPath);
                pomFiles.add(new PomFile(pomPath, content));
            }
        }

        log.debug("Found {} pom.xml files in {}", pomFiles.size(), repoPath);
        return pomFiles;
    }

    /**
     * Find all package.json files in repository (npm projects)
     */
    private List<NpmFile> findPackageJsonFiles(Path repoPath) throws IOException {
        List<NpmFile> npmFiles = new ArrayList<>();

        try (var stream = Files.walk(repoPath)) {
            List<Path> jsonPaths = stream
                    .filter(path -> path.getFileName().toString().equals("package.json"))
                    .collect(Collectors.toList());

            for (Path jsonPath : jsonPaths) {
                String content = Files.readString(jsonPath);
                npmFiles.add(new NpmFile(jsonPath, content));
            }
        }

        log.debug("Found {} package.json files in {}", npmFiles.size(), repoPath);
        return npmFiles;
    }

    /**
     * Generate patch for a pom.xml file
     */
    private PomPatch generatePomPatch(PomFile pomFile, List<DependencyVulnerability> vulnerabilities) {
        String originalContent = pomFile.content;
        String modifiedContent = originalContent;

        List<String> changes = new ArrayList<>();

        // Update each vulnerable dependency
        for (DependencyVulnerability vuln : vulnerabilities) {
            String groupId = vuln.getGroupId();
            String artifactId = vuln.getArtifactId();
            String currentVersion = vuln.getCurrentVersion();
            String recommendedVersion = vuln.getRecommendedVersion();

            // Pattern to match dependency declaration
            Pattern pattern = Pattern.compile(
                    "<dependency>\\s*" +
                    "<groupId>" + Pattern.quote(groupId) + "</groupId>\\s*" +
                    "<artifactId>" + Pattern.quote(artifactId) + "</artifactId>\\s*" +
                    "<version>" + Pattern.quote(currentVersion) + "</version>",
                    Pattern.DOTALL
            );

            Matcher matcher = pattern.matcher(modifiedContent);
            if (matcher.find()) {
                String replacement = matcher.group().replace(
                        "<version>" + currentVersion + "</version>",
                        "<version>" + recommendedVersion + "</version>"
                );
                modifiedContent = matcher.replaceFirst(Matcher.quoteReplacement(replacement));
                changes.add(String.format("%s:%s %s ‚Üí %s (fixes %s)", 
                        groupId, artifactId, currentVersion, recommendedVersion, vuln.getCveId()));
                
                log.debug("Updated {}:{} from {} to {}", groupId, artifactId, currentVersion, recommendedVersion);
            }
        }

        // Generate unified diff
        String diff = "";
        if (!originalContent.equals(modifiedContent)) {
            diff = generateUnifiedDiff(
                    pomFile.path.toString(),
                    originalContent,
                    modifiedContent
            );
        }

        return PomPatch.builder()
                .filePath(pomFile.path.toString())
                .originalContent(originalContent)
                .modifiedContent(modifiedContent)
                .unifiedDiff(diff)
                .changes(changes)
                .build();
    }

    /**
     * Generate patch for a package.json file (npm).
     * Updates dependency versions for vulnerable packages using recommendedVersion.
     */
    private PomPatch generatePackageJsonPatch(NpmFile npmFile, List<DependencyVulnerability> vulnerabilities) {
        String originalContent = npmFile.content;
        String modifiedContent = originalContent;
        List<String> changes = new ArrayList<>();

        // For safety, operate via regex replacements on dependencies and devDependencies blocks
        for (DependencyVulnerability vuln : vulnerabilities) {
            String pkgName = vuln.getArtifactId(); // npm package name lives in artifactId field
            String currentVersion = vuln.getCurrentVersion();
            String recommendedVersion = vuln.getRecommendedVersion();

            if (pkgName == null || recommendedVersion == null || currentVersion == null) continue;

            // Normalize caret/tilde from current version if present
            String normalizedCurrent = currentVersion.startsWith("^") || currentVersion.startsWith("~")
                    ? currentVersion.substring(1) : currentVersion;

            // Build patterns for dependencies and devDependencies entries
            // Matches: "@pkg/name": "<version>"
            String depKey = Pattern.quote("\"" + pkgName + "\"");
            Pattern depPattern = Pattern.compile(depKey + "\s*:\s*\"[^\"]*\"", Pattern.MULTILINE);

            Matcher m = depPattern.matcher(modifiedContent);
            boolean updatedAny = false;
            StringBuffer sb = new StringBuffer();
            while (m.find()) {
                // Only update if the current version in file matches or is compatible; we'll replace regardless to recommendedVersion
                String replacement = depKey + ": \"" + recommendedVersion + "\"";
                m.appendReplacement(sb, Matcher.quoteReplacement(replacement));
                updatedAny = true;
            }
            m.appendTail(sb);
            if (updatedAny) {
                modifiedContent = sb.toString();
                changes.add(String.format("%s %s ‚Üí %s (fixes %s)", pkgName, normalizedCurrent, recommendedVersion, vuln.getCveId()));
                log.debug("Updated npm package {} from {} to {}", pkgName, normalizedCurrent, recommendedVersion);
            }
        }

        // Generate unified diff
        String diff = "";
        if (!originalContent.equals(modifiedContent)) {
            diff = generateUnifiedDiff(
                    npmFile.path.toString(),
                    originalContent,
                    modifiedContent
            );
        }

        return PomPatch.builder()
                .filePath(npmFile.path.toString())
                .originalContent(originalContent)
                .modifiedContent(modifiedContent)
                .unifiedDiff(diff)
                .changes(changes)
                .build();
    }

    /**
     * Generate unified diff using java-diff-utils
     */
    private String generateUnifiedDiff(String filename, String original, String modified) {
        try {
            List<String> originalLines = Arrays.asList(original.split("\n"));
            List<String> modifiedLines = Arrays.asList(modified.split("\n"));

            Patch<String> patch = DiffUtils.diff(originalLines, modifiedLines);
            List<String> unifiedDiff = UnifiedDiffUtils.generateUnifiedDiff(
                    "a/" + filename,
                    "b/" + filename,
                    originalLines,
                    patch,
                    3  // context lines
            );

            return String.join("\n", unifiedDiff);
        } catch (Exception e) {
            log.error("Error generating unified diff: {}", e.getMessage());
            return "";
        }
    }

    /**
     * Generate commit message
     */
    private String generateCommitMessage(List<DependencyVulnerability> vulnerabilities) {
        StringBuilder message = new StringBuilder();
        message.append("Security Fix: Update vulnerable dependencies\n\n");

        // Group by severity
        Map<VulnerabilitySeverity, List<DependencyVulnerability>> bySeverity = vulnerabilities.stream()
                .collect(Collectors.groupingBy(DependencyVulnerability::getSeverity));

        for (VulnerabilitySeverity severity : Arrays.asList(
                VulnerabilitySeverity.CRITICAL,
                VulnerabilitySeverity.HIGH,
                VulnerabilitySeverity.MEDIUM,
                VulnerabilitySeverity.LOW)) {
            
            List<DependencyVulnerability> vulns = bySeverity.get(severity);
            if (vulns != null && !vulns.isEmpty()) {
                message.append(String.format("%s (%d):\n", severity.getDisplayName(), vulns.size()));
                for (DependencyVulnerability vuln : vulns) {
                    message.append(String.format("- %s:%s %s ‚Üí %s (%s)\n",
                            vuln.getGroupId(),
                            vuln.getArtifactId(),
                            vuln.getCurrentVersion(),
                            vuln.getRecommendedVersion(),
                            vuln.getCveId()));
                }
                message.append("\n");
            }
        }

        return message.toString().trim();
    }

    /**
     * Generate PR description
     */
    private String generatePRDescription(RepoVulnerabilityReport report, 
                                        List<DependencyVulnerability> fixedVulnerabilities) {
        StringBuilder desc = new StringBuilder();
        desc.append("## üîê Security Update: Fix Vulnerable Dependencies\n\n");
        
        desc.append("### Summary\n");
        desc.append(String.format("This PR addresses **%d vulnerable dependencies** detected in the repository.\n\n",
                fixedVulnerabilities.size()));

        desc.append("### Vulnerabilities Fixed\n\n");
        for (DependencyVulnerability vuln : fixedVulnerabilities) {
            desc.append(String.format("#### %s - %s\n", vuln.getCveId(), vuln.getSeverity().getDisplayName()));
            desc.append(String.format("- **Package**: `%s:%s`\n", vuln.getGroupId(), vuln.getArtifactId()));
            desc.append(String.format("- **Current Version**: %s\n", vuln.getCurrentVersion()));
            desc.append(String.format("- **Fixed Version**: %s\n", vuln.getRecommendedVersion()));
            desc.append(String.format("- **CVSS Score**: %.1f\n", vuln.getCvssScore()));
            desc.append(String.format("- **Description**: %s\n\n", vuln.getDescription()));
        }

        desc.append("### Testing Checklist\n");
        desc.append("- [ ] All unit tests pass\n");
        desc.append("- [ ] Integration tests pass\n");
        desc.append("- [ ] Application builds successfully\n");
        desc.append("- [ ] No breaking changes detected\n");
        desc.append("- [ ] Vulnerability scan shows improvements\n\n");

        desc.append("### Risk Assessment\n");
        desc.append(String.format("- **Before**: Risk Score %.1f (%s)\n", 
                report.getRiskScore(), report.getRiskLevel()));
        desc.append("- **After**: Reduced risk by addressing critical vulnerabilities\n\n");

        desc.append("---\n");
        desc.append("*This PR was generated automatically by the Repository Intelligence Agent*\n");

        return desc.toString();
    }

    /**
     * Create ZIP bundle with patches and documentation
     */
    private Path createZipBundle(String repoName, List<PomPatch> patches, 
                                 String commitMessage, String prDescription) throws IOException {
        String timestamp = String.valueOf(System.currentTimeMillis());
        Path zipPath = tempDir.resolve(String.format("%s-vulnerability-fix-%s.zip", repoName, timestamp));

        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zipPath))) {
            // Add patched files (pom.xml or package.json) and their originals with accurate names
            for (int i = 0; i < patches.size(); i++) {
                PomPatch patch = patches.get(i);
                String originalPath = patch.filePath;
                String baseName = Paths.get(originalPath).getFileName().toString();
                String ext;
                if (baseName.endsWith("pom.xml")) {
                    ext = "xml";
                } else if (baseName.equals("package.json")) {
                    ext = "json";
                } else {
                    // fallback to txt for unknown types
                    ext = "txt";
                }

                // Patched file
                String patchedName = String.format("patched-%d-%s.%s", i + 1, baseName.replace('.', '_'), ext);
                ZipEntry entry = new ZipEntry(patchedName);
                zos.putNextEntry(entry);
                zos.write(patch.modifiedContent.getBytes());
                zos.closeEntry();

                // Diff file
                if (!patch.unifiedDiff.isEmpty()) {
                    ZipEntry diffEntry = new ZipEntry(String.format("patch-%d.diff", i + 1));
                    zos.putNextEntry(diffEntry);
                    zos.write(patch.unifiedDiff.getBytes());
                    zos.closeEntry();
                }

                // Original file for reference
                String originalName = String.format("original-%d-%s.%s", i + 1, baseName.replace('.', '_'), ext);
                ZipEntry originalEntry = new ZipEntry(originalName);
                zos.putNextEntry(originalEntry);
                zos.write(patch.originalContent.getBytes());
                zos.closeEntry();
            }

            // Add commit message
            ZipEntry commitEntry = new ZipEntry("COMMIT_MESSAGE.txt");
            zos.putNextEntry(commitEntry);
            zos.write(commitMessage.getBytes());
            zos.closeEntry();

            // Add PR description
            ZipEntry prEntry = new ZipEntry("PR_DESCRIPTION.md");
            zos.putNextEntry(prEntry);
            zos.write(prDescription.getBytes());
            zos.closeEntry();

            // Add README
            String readme = generateReadme(patches);
            ZipEntry readmeEntry = new ZipEntry("README.md");
            zos.putNextEntry(readmeEntry);
            zos.write(readme.getBytes());
            zos.closeEntry();
        }

        log.info("Created fix bundle: {}", zipPath);
        return zipPath;
    }

    /**
     * Generate README for fix bundle
     */
    private String generateReadme(List<PomPatch> patches) {
        StringBuilder readme = new StringBuilder();
        readme.append("# Vulnerability Fix Bundle\n\n");
        readme.append("## Contents\n\n");
        readme.append("This bundle contains:\n");
        readme.append("- Patched dependency files (pom.xml, package.json) with updated versions\n");
        readme.append("- Unified diff patches (*.diff)\n");
        readme.append("- Original files for reference (mirrors patched files)\n");
        readme.append("- Commit message template\n");
        readme.append("- PR description template\n\n");

        readme.append("## How to Apply\n\n");
        readme.append("### Option 1: Manual Application\n");
        readme.append("1. Review the patched files (`pom.xml`, `package.json`)\n");
        readme.append("2. Apply the changes to your repository (Maven: update `<version>` tags; npm: update versions in `package.json`)\n");
        readme.append("3. Run `mvn clean install` (Maven) or `npm install && npm run build` (npm) to verify the build\n");
        readme.append("4. Commit with the provided commit message\n\n");

        readme.append("### Option 2: Using Git Apply\n");
        readme.append("```bash\n");
        readme.append("# Apply the patch\n");
        readme.append("git apply patch-1.diff\n\n");
        readme.append("# Verify changes\n");
        readme.append("git diff\n\n");
        readme.append("# Commit with provided message\n");
        readme.append("git commit -F COMMIT_MESSAGE.txt\n");
        readme.append("```\n\n");

        readme.append("## Changes Summary\n\n");
        for (int i = 0; i < patches.size(); i++) {
            PomPatch patch = patches.get(i);
            readme.append(String.format("### File %d: %s\n", i + 1, patch.filePath));
            for (String change : patch.changes) {
                readme.append(String.format("- %s\n", change));
            }
            readme.append("\n");
        }

        readme.append("## Testing\n\n");
        readme.append("After applying the fixes:\n");
        readme.append("1. Run `mvn clean install` (Maven) or `npm install && npm run build` (npm) to ensure the build succeeds\n");
        readme.append("2. Run all unit tests: `mvn test`\n");
        readme.append("3. Run integration tests if applicable\n");
        readme.append("4. Verify application functionality\n\n");

        readme.append("---\n");
        readme.append("*Generated by Repository Intelligence Agent*\n");

        return readme.toString();
    }

    /**
     * Helper class for POM file
     */
    @Data
    private static class PomFile {
        private final Path path;
        private final String content;
    }

    /**
     * Helper class for package.json file
     */
    @Data
    private static class NpmFile {
        private final Path path;
        private final String content;
    }

    /**
     * POM patch result
     */
    @Data
    @lombok.Builder
    public static class PomPatch {
        private String filePath;
        private String originalContent;
        private String modifiedContent;
        private String unifiedDiff;
        private List<String> changes;

        public boolean hasChanges() {
            return changes != null && !changes.isEmpty();
        }
    }

    /**
     * Fix bundle result
     */
    @Data
    @lombok.Builder
    public static class FixBundle {
        private String repoName;
        private List<PomPatch> patches;
        private String commitMessage;
        private String prDescription;
        private String zipPath;
        private int fixedCount;
    }
}
