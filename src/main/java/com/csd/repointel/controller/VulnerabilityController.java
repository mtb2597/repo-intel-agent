package com.csd.repointel.controller;

import com.csd.repointel.model.RepoVulnerabilityReport;
import com.csd.repointel.model.VulnerabilityStatistics;
import com.csd.repointel.service.VulnerabilityAnalysisService;
import com.csd.repointel.service.VulnerabilityExportService;
import com.csd.repointel.service.VulnerabilityFixService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * REST API controller for vulnerability detection and fix generation
 */
@RestController
@RequestMapping("/api/vulnerabilities")
@Slf4j
public class VulnerabilityController {

    private final VulnerabilityAnalysisService analysisService;
    private final VulnerabilityFixService fixService;
    private final VulnerabilityExportService exportService;

    public VulnerabilityController(VulnerabilityAnalysisService analysisService,
                                   VulnerabilityFixService fixService,
                                   VulnerabilityExportService exportService) {
        this.analysisService = analysisService;
        this.fixService = fixService;
        this.exportService = exportService;
    }

    /**
     * Get vulnerability reports for all repositories
     */
    @GetMapping
    public ResponseEntity<List<RepoVulnerabilityReport>> getAllVulnerabilities() {
        log.info("GET /api/vulnerabilities - Getting all vulnerability reports");
        try {
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            return ResponseEntity.ok(reports);
        } catch (Exception e) {
            log.error("Error getting vulnerability reports: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get vulnerability report for specific repository
     */
    @GetMapping("/{repoName}")
    public ResponseEntity<RepoVulnerabilityReport> getRepositoryVulnerabilities(@PathVariable String repoName) {
        log.info("GET /api/vulnerabilities/{} - Getting vulnerability report", repoName);
        try {
            RepoVulnerabilityReport report = analysisService.analyzeRepositoryByName(repoName);
            return ResponseEntity.ok(report);
        } catch (IllegalArgumentException e) {
            log.warn("Repository not found: {}", repoName);
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            log.error("Error getting vulnerability report for {}: {}", repoName, e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Trigger vulnerability check (re-analyze all repos)
     */
    @PostMapping("/check")
    public ResponseEntity<List<RepoVulnerabilityReport>> checkVulnerabilities() {
        log.info("POST /api/vulnerabilities/check - Triggering vulnerability check");
        try {
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            return ResponseEntity.ok(reports);
        } catch (Exception e) {
            log.error("Error checking vulnerabilities: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Get global vulnerability statistics
     */
    @GetMapping("/statistics")
    public ResponseEntity<VulnerabilityStatistics> getGlobalStatistics() {
        log.info("GET /api/vulnerabilities/statistics - Getting global statistics");
        try {
            VulnerabilityStatistics stats = analysisService.getGlobalStatistics();
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("Error getting statistics: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Preview fix for a repository
     */
    @GetMapping("/fix/preview/{repoName}")
    public ResponseEntity<VulnerabilityFixService.FixBundle> previewFix(@PathVariable String repoName) {
        log.info("GET /api/vulnerabilities/fix/preview/{} - Previewing fix", repoName);
        try {
            VulnerabilityFixService.FixBundle bundle = fixService.generateFixBundle(repoName);
            return ResponseEntity.ok(bundle);
        } catch (IllegalArgumentException | IllegalStateException e) {
            log.warn("Cannot generate fix for {}: {}", repoName, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            log.error("Error previewing fix for {}: {}", repoName, e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Download fix bundle as ZIP
     */
    @GetMapping("/fix/download/{repoName}")
    public ResponseEntity<Resource> downloadFix(@PathVariable String repoName) {
        log.info("GET /api/vulnerabilities/fix/download/{} - Downloading fix bundle", repoName);
        try {
            VulnerabilityFixService.FixBundle bundle = fixService.generateFixBundle(repoName);
            Path zipPath = Path.of(bundle.getZipPath());
            
            Resource resource = new FileSystemResource(zipPath);
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, 
                            "attachment; filename=\"" + zipPath.getFileName().toString() + "\"")
                    .contentType(MediaType.APPLICATION_OCTET_STREAM)
                    .body(resource);
        } catch (IllegalArgumentException | IllegalStateException e) {
            log.warn("Cannot download fix for {}: {}", repoName, e.getMessage());
            return ResponseEntity.badRequest().build();
        } catch (Exception e) {
            log.error("Error downloading fix for {}: {}", repoName, e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Export vulnerability reports as CSV
     */
    @GetMapping("/export/csv")
    public ResponseEntity<Resource> exportCsv() {
        log.info("GET /api/vulnerabilities/export/csv - Exporting as CSV");
        try {
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            byte[] csv = exportService.exportCsv(reports);
            
            ByteArrayResource resource = new ByteArrayResource(csv);
            String filename = String.format("vulnerabilities-%s.csv", 
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")));
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
                    .contentType(MediaType.parseMediaType("text/csv"))
                    .body(resource);
        } catch (Exception e) {
            log.error("Error exporting CSV: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Export vulnerability reports as Excel
     */
    @GetMapping("/export/excel")
    public ResponseEntity<Resource> exportExcel() {
        log.info("GET /api/vulnerabilities/export/excel - Exporting as Excel");
        try {
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            byte[] excel = exportService.exportExcel(reports);
            
            ByteArrayResource resource = new ByteArrayResource(excel);
            String filename = String.format("vulnerabilities-%s.xlsx", 
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")));
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
                    .contentType(MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"))
                    .body(resource);
        } catch (Exception e) {
            log.error("Error exporting Excel: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Export vulnerability reports as JSON
     */
    @GetMapping("/export/json")
    public ResponseEntity<Resource> exportJson() {
        log.info("GET /api/vulnerabilities/export/json - Exporting as JSON");
        try {
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            byte[] json = exportService.exportJson(reports);
            
            ByteArrayResource resource = new ByteArrayResource(json);
            String filename = String.format("vulnerabilities-%s.json", 
                    LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")));
            
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(resource);
        } catch (Exception e) {
            log.error("Error exporting JSON: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Export vulnerability reports as HTML
     */
    @GetMapping("/export/html")
    public ResponseEntity<String> exportHtml() {
        log.info("GET /api/vulnerabilities/export/html - Exporting as HTML");
        try {
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            String html = exportService.exportHtml(reports);
            
            return ResponseEntity.ok()
                    .contentType(MediaType.TEXT_HTML)
                    .body(html);
        } catch (Exception e) {
            log.error("Error exporting HTML: {}", e.getMessage(), e);
            return ResponseEntity.internalServerError().build();
        }
    }
}
