package com.csd.repointel.controller;

import com.csd.repointel.model.DependencyVulnerability;
import com.csd.repointel.model.RepoVulnerabilityReport;
import com.csd.repointel.service.LlmAssistantService;
import com.csd.repointel.service.VulnerabilityAnalysisService;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Controller for natural language vulnerability queries.
 * Uses LLM for NLP/explanations but vulnerability data comes from real sources.
 */
@RestController
@RequestMapping("/api/query")
@Slf4j
public class VulnerabilityQueryController {

    private final VulnerabilityAnalysisService analysisService;
    private final LlmAssistantService llmService;

    public VulnerabilityQueryController(VulnerabilityAnalysisService analysisService,
                                       LlmAssistantService llmService) {
        this.analysisService = analysisService;
        this.llmService = llmService;
    }

    /**
     * Natural language query endpoint.
     * Example: "Show all vulnerabilities in my repos"
     *          "Which repos are affected by CVE-2021-44228?"
     *          "What version should I upgrade log4j-core to?"
     */
    @PostMapping("/ask")
    public ResponseEntity<QueryResponse> ask(@RequestBody QueryRequest request) {
        log.info("Processing query: {}", request.getQuestion());

        try {
            // Step 1: Use LLM to parse intent (but don't trust it for data)
            LlmAssistantService.QueryIntent intent = llmService.parseUserQuery(request.getQuestion());
            log.info("Parsed intent: {}", intent.getIntent());

            // Step 2: Fetch REAL vulnerability data based on intent
            List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
            
            // Step 3: Filter data based on parsed intent
            Map<String, Object> results = filterResultsByIntent(intent, reports);

            // Step 4: Use LLM to generate human-friendly explanation of REAL data
            String explanation = llmService.generateExplanation(
                "User asked: " + request.getQuestion(),
                results
            );

            return ResponseEntity.ok(QueryResponse.builder()
                    .answer(explanation)
                    .data(results)
                    .intent(intent.getIntent())
                    .dataSource("OSV.dev / Local CVE Database")
                    .llmUsed(true)
                    .build());

        } catch (Exception e) {
            log.error("Query processing failed", e);
            return ResponseEntity.ok(QueryResponse.builder()
                    .answer("Error processing query: " + e.getMessage())
                    .dataSource("Error")
                    .llmUsed(false)
                    .build());
        }
    }

    /**
     * Get vulnerability details for a specific CVE.
     * Data comes from real sources, LLM just explains it.
     */
    @GetMapping("/cve/{cveId}")
    public ResponseEntity<QueryResponse> getCveDetails(@PathVariable String cveId) {
        log.info("Looking up CVE: {}", cveId);

        List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
        
        // Find all occurrences of this CVE in scanned repos
        List<Map<String, Object>> matches = new ArrayList<>();
        for (RepoVulnerabilityReport report : reports) {
            for (DependencyVulnerability vuln : report.getVulnerabilities()) {
                if (cveId.equalsIgnoreCase(vuln.getCveId())) {
                    matches.add(Map.of(
                        "repo", report.getRepoName(),
                        "package", vuln.getGroupId() + ":" + vuln.getArtifactId(),
                        "currentVersion", vuln.getCurrentVersion(),
                        "severity", vuln.getSeverity(),
                        "affectedRange", vuln.getAffectedRange() != null ? vuln.getAffectedRange() : "Unknown",
                        "fixedVersion", vuln.getRecommendedVersion() != null ? vuln.getRecommendedVersion() : "N/A",
                        "source", "OSV.dev / Local CVE Database"
                    ));
                }
            }
        }

        Map<String, Object> data = Map.of(
            "cveId", cveId,
            "foundIn", matches.size() + " locations",
            "matches", matches
        );

        String explanation = llmService.generateExplanation(
            "CVE details for " + cveId,
            data
        );

        return ResponseEntity.ok(QueryResponse.builder()
                .answer(explanation)
                .data(data)
                .intent("find_by_cve")
                .dataSource("Real vulnerability data")
                .llmUsed(true)
                .build());
    }

    /**
     * Get upgrade recommendations for a specific package.
     * ONLY recommends versions that exist in real vulnerability data.
     */
    @GetMapping("/upgrade/{groupId}/{artifactId}")
    public ResponseEntity<QueryResponse> getUpgradeRecommendation(
            @PathVariable String groupId,
            @PathVariable String artifactId) {
        
        log.info("Getting upgrade recommendation for {}:{}", groupId, artifactId);

        List<RepoVulnerabilityReport> reports = analysisService.analyzeAllRepositories();
        
        List<Map<String, Object>> upgrades = new ArrayList<>();
        for (RepoVulnerabilityReport report : reports) {
            for (DependencyVulnerability vuln : report.getVulnerabilities()) {
                if (groupId.equals(vuln.getGroupId()) && artifactId.equals(vuln.getArtifactId())) {
                    if (vuln.getRecommendedVersion() != null) { // ONLY include if we have real fix
                        upgrades.add(Map.of(
                            "repo", report.getRepoName(),
                            "currentVersion", vuln.getCurrentVersion(),
                            "fixedVersion", vuln.getRecommendedVersion(),
                            "cveId", vuln.getCveId(),
                            "severity", vuln.getSeverity(),
                            "source", "OSV.dev / Local CVE Database"
                        ));
                    }
                }
            }
        }

        Map<String, Object> data = Map.of(
            "package", groupId + ":" + artifactId,
            "upgradesAvailable", upgrades.size(),
            "recommendations", upgrades
        );

        String explanation = upgrades.isEmpty() 
            ? "No upgrade recommendations available. Either the package is not vulnerable, or no fixed versions are documented in the vulnerability database."
            : llmService.generateUpgradeRecommendation(data);

        return ResponseEntity.ok(QueryResponse.builder()
                .answer(explanation)
                .data(data)
                .intent("suggest_fixes")
                .dataSource("Real vulnerability data with documented fixes")
                .llmUsed(true)
                .build());
    }

    /**
     * Filter vulnerability results based on parsed intent.
     * All filtering is data-driven, not LLM-invented.
     */
    private Map<String, Object> filterResultsByIntent(
            LlmAssistantService.QueryIntent intent,
            List<RepoVulnerabilityReport> reports) {
        
        Map<String, Object> results = new HashMap<>();

        switch (intent.getIntent()) {
            case "list_vulnerabilities":
                results.put("totalRepos", reports.size());
                results.put("vulnerableRepos", reports.stream()
                    .filter(r -> r.getStatistics().getVulnerableDependencies() > 0)
                    .count());
                results.put("totalVulnerabilities", reports.stream()
                    .mapToInt(r -> r.getStatistics().getVulnerableDependencies())
                    .sum());
                results.put("reports", reports);
                break;

            case "find_by_cve":
                // Extract CVE from entities
                Map<String, Object> entities = intent.getEntities();
                if (entities != null && entities.containsKey("cve")) {
                    results.put("filteredByCve", entities.get("cve"));
                }
                results.put("reports", reports);
                break;

            case "suggest_fixes":
                List<Map<String, Object>> fixableVulns = new ArrayList<>();
                for (RepoVulnerabilityReport report : reports) {
                    for (DependencyVulnerability vuln : report.getVulnerabilities()) {
                        if (vuln.getRecommendedVersion() != null) { // ONLY with real fix
                            fixableVulns.add(Map.of(
                                "repo", report.getRepoName(),
                                "package", vuln.getGroupId() + ":" + vuln.getArtifactId(),
                                "from", vuln.getCurrentVersion(),
                                "to", vuln.getRecommendedVersion(),
                                "cve", vuln.getCveId(),
                                "severity", vuln.getSeverity()
                            ));
                        }
                    }
                }
                results.put("fixableVulnerabilities", fixableVulns.size());
                results.put("fixes", fixableVulns);
                break;

            case "summary":
                results.put("summary", generateDataDrivenSummary(reports));
                break;

            default:
                results.put("reports", reports);
        }

        return results;
    }

    private Map<String, Object> generateDataDrivenSummary(List<RepoVulnerabilityReport> reports) {
        int totalVulns = reports.stream()
            .mapToInt(r -> r.getStatistics().getVulnerableDependencies())
            .sum();
        
        int fixable = 0;
        int critical = 0, high = 0, medium = 0, low = 0;

        for (RepoVulnerabilityReport report : reports) {
            for (DependencyVulnerability vuln : report.getVulnerabilities()) {
                if (vuln.getRecommendedVersion() != null) fixable++;
                
                switch (vuln.getSeverity()) {
                    case CRITICAL: critical++; break;
                    case HIGH: high++; break;
                    case MEDIUM: medium++; break;
                    case LOW: low++; break;
                    default: break; // UNKNOWN, NONE
                }
            }
        }

        return Map.of(
            "totalRepositories", reports.size(),
            "totalVulnerabilities", totalVulns,
            "fixableVulnerabilities", fixable,
            "severityBreakdown", Map.of(
                "CRITICAL", critical,
                "HIGH", high,
                "MEDIUM", medium,
                "LOW", low
            )
        );
    }

    @Data
    public static class QueryRequest {
        private String question;
    }

    @lombok.Builder
    @Data
    public static class QueryResponse {
        private String answer;
        private Map<String, Object> data;
        private String intent;
        private String dataSource;
        private boolean llmUsed;
    }
}
